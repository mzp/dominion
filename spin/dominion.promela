#define BUF_SIZE 10
#define CLIENT_NUM 3
#define CARD_NUM 20

#define MsgType byte
#define KEEP 1
#define NEXT 2
#define EventNotify  3
#define EventSend  4
#define Error  5
#define INC(X) X = X + 1

mtype = { Connect, Chat, Start, Pass, Action, Buy, NextPhase };
chan server = [BUF_SIZE] of { mtype, chan, MsgType };

bool Go = false;

proctype Oneshot(chan client; MsgType value){
  if
    :: (Go == true) -> client ! value;
  fi
}

inline error(ch){
  printf("ERROR\n");
  ch ! Error;
}

bool fireChat = false;
proctype chatEvent(chan client) {
  bool prev = fireChat;
  do
    :: client ? EventSend ->
       atomic { fireChat = !fireChat };
    :: prev != fireChat ->
       atomic {
	 prev = fireChat;
	 if
	   :: nfull(client) ->
	      client ! EventNotify
	   :: skip
	 fi
       }
  od
}

proctype Server()
{
  int user = 0;
  int wait = 0;
  chan ch;
  chan clients[CLIENT_NUM];
  byte cards[CARD_NUM];

  /* initial state */
  do
    :: server ? Connect(ch, _) ->
       ch ! user;
       clients[user] = ch;
       user = user + 1;
    :: server ? Start(ch, _) ->
       wait = wait + 1;
       run Oneshot(ch, 0);
    :: (wait == user) && (user == 2) ->
       Go = true;
       goto game_start;
    :: server ? Chat(ch, _) ->
       run chatEvent(ch);
  od;

  int turn = 0;
  int count = 0;
  int id = 0;

game_start:
  printf("game start[%d]\n",turn);

action:
  clients[turn] ! turn;
  count = 0;
  do
    :: server ? Action(ch,id) ->
       if
	 ::(id == turn) ->
	    printf("action[%d]\n", turn);
	    if
	      ::(count == 100) -> ch ! NEXT; goto buy;
	      :: ch ! KEEP; INC(count);
	      :: ch ! NEXT; goto buy
	    fi
	 :: else ->
	    skip;
       fi
    :: server ? NextPhase(ch, id) ->
       if
	 ::(id == turn) ->
	    ch ! NEXT;
	    goto buy;
       fi
    :: server ? Chat(ch, _) ->
       run chatEvent(ch);
    :: server ? (_,ch,_) ->
       error(ch);
  od;

buy:
  count = 0;
  do
    :: server ? Buy(ch,id) ->
       if
	 ::(id == turn) ->
	    printf("buy[%d]\n", turn);
	    if
	      :: (count == 100) -> ch ! NEXT; goto clean;
	      :: ch ! KEEP; INC(count);
	      :: ch ! NEXT; goto clean;
	    fi
	 :: else ->
	    skip;
       fi
    :: server ? NextPhase(ch, id) ->
       if
	 ::(id == turn) ->
	    ch ! NEXT;
	    goto clean;
       fi
    :: server ? (_,ch,_) ->
       error(ch);
  od;

clean:
  printf("clean[%d]\n", turn);
  turn = (turn + 1) % user;
  goto action;

finish:
  printf("%d win", turn);
}

proctype ChatRecv(pid my_pid; chan ch){
  do
    :: ch ? EventNotify ->
       printf("event[%d]\n", my_pid);
  od
}

proctype User() {
  chan me = [BUF_SIZE] of { MsgType };
  chan chat = [BUF_SIZE] of { MsgType };
  int id;

  run ChatRecv(_pid, chat);

  server ! Connect(me,0);
  if
    :: me ? id ->
       printf("my id: %d\n",id);
       server ! Start(me, id);
       server ! Chat(chat, id);

       if
	 :: me ? _ ->
action:
	    printf("event ->\n");
	    chat ! EventSend;
	    if
	      :: me ? _ ->
progress:
		 /* action */
		 server ! Action(me, id);
		 do
		   :: me ? KEEP ->
		      if
			:: server ! Action(me, id)
			:: server ! NextPhase(me, id)
		      fi
		   :: me ? NEXT ->
		      /* buy */
		      server ! Buy(me, id);
		      do
			:: me ? KEEP ->
			   if
			     :: server ! Buy(me, id)
			     :: server ! NextPhase(me,id)
			   fi
			:: me ? NEXT ->
			   goto action;
		      od
		 od
	    fi
       fi
  fi
}

proctype Gorilla(){
    chan me = [BUF_SIZE] of { MsgType };
  chan chat = [BUF_SIZE] of { MsgType };
  int id;

  run ChatRecv(_pid, chat);

  server ! Connect(me,0);
  if
    :: me ? id ->
       printf("my id: %d\n",id);
       server ! Start(me, id);
       server ! Chat(chat, id);

       if
	 :: me ? _ ->
	    do
	      :: me ? _ ->
		 /* action */
		 if
		   :: printf("gorilla action\n"); server ! Action(me, id)
		   :: printf("gorilla buy\n"); server ! Buy(me, id)
		   :: printf("gorilla next\n"); server ! NextPhase(me, id)
		 fi
	    od
       fi
  fi
}

init {
  run Server();
  run Gorilla();
  run User();
}